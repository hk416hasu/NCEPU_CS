-- generated by hk416hasu
-- 失败了 但是我举得思路没有问题
-- 尤其建议写代码之前先确定时序图 + 设定数码管显示信息
library IEEE;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity cpu is
	Port ( 
		CLK       : in STD_LOGIC; -- 单步时钟信号, 控制取指
		CLK0      : in STD_LOGIC; -- 10MHZ时钟信号, 自动执行
		RST       : in STD_LOGIC; -- 复位信号
		INPUT     : in STD_LOGIC_VECTOR (15 downto 0); -- 拨码开关输入指令
		OUTPUT    : out STD_LOGIC_VECTOR(15 downto 0); -- LED输出
		--stateCnt1 : out STD_LOGIC_VECTOR(6  downto 0); -- 7段数码管
		--stateCnt2 : out STD_LOGIC_VECTOR(6  downto 0); -- 7段数码管
		M_EN      : out STD_LOGIC; -- Memory_Enable
		M_OE      : out STD_LOGIC; -- Memory_Output_Enable
		M_WE      : out STD_LOGIC; -- Memory_Write_Enable
		M_Addr    : out   STD_LOGIC_VECTOR(17 downto 0); -- SRAM地址信号, 18位, 与外总线连接
		M_Data    : inout STD_LOGIC_VECTOR(15 downto 0)  -- SRAM数据信号, 16位, 与外总线连接
	);
end entity cpu;

architecture bhv of cpu is
	signal r0, r1, r2, r3, r4, r5, r6, r7 : STD_LOGIC_VECTOR(15 downto 0); -- 通用寄存器组
	signal ACC : STD_LOGIC_VECTOR(15 downto 0); -- 累加寄存器
	signal B : STD_LOGIC_VECTOR(15 downto 0);
	signal PC : STD_LOGIC_VECTOR(15 downto 0); -- 程序计数器
	signal IR : STD_LOGIC_VECTOR(15 downto 0); -- 指令寄存器
	signal OP : STD_LOGIC_VECTOR(4 downto 0); -- 
	signal MAR : STD_LOGIC_VECTOR(15 downto 0);
	signal MBR : STD_LOGIC_VECTOR(15 downto 0);
	signal SR : STD_LOGIC_VECTOR(15 downto 0); -- 移位寄存器
	signal data : STD_LOGIC_VECTOR(15 downto 0); -- 内总线
	
	signal MachineState : integer range 0 to 1;
	signal ClockState : integer range 0 to 3;
	signal ZF : STD_LOGIC;
	-- signal ALUout : STD_LOGIC_VECTOR(15 downto 0);
	
	signal rx, ry, rz : STD_LOGIC_VECTOR(2 downto 0); -- 目的寄存器
	
	-- shared variable immd : STD_LOGIC_VECTOR(15 downto 0); -- 立即数
	
	signal T0 : STD_LOGIC;
	signal T1 : STD_LOGIC;
	signal T2 : STD_LOGIC;
	signal T3 : STD_LOGIC;
	
	signal Ex : STD_LOGIC; -- Execute
	signal Fe : STD_LOGIC; -- Fetch
	
	signal LW : STD_LOGIC;
	signal SW : STD_LOGIC;
	signal LI : STD_LOGIC;
	signal BEQZ : STD_LOGIC;
	signal ADDIU : STD_LOGIC;
	signal ADDU : STD_LOGIC;
	signal Branch : STD_LOGIC;
	
	-- 一些cu将会发出的控制信号
	signal SendPCtoAcc : STD_LOGIC;
	signal Pass_ALU : STD_LOGIC;
	signal DM_SR : STD_LOGIC;
	signal CPMAR : STD_LOGIC;
	signal EMAR : STD_LOGIC;
	signal R : STD_LOGIC;
	signal W : STD_LOGIC;
	signal SIR : STD_LOGIC;
	signal Add_ALU : STD_LOGIC;
	signal CPPC : STD_LOGIC;	-- 由于是从拨码开关取值，没用到pc，Branch指令失效，可考虑在rst中存指令至内存
	signal SendIRtoAcc : STD_LOGIC;
	signal SLL11_ALU : STD_LOGIC;
	signal SRA11_SR : STD_LOGIC;
	signal CPACC : STD_LOGIC;
	signal SendRxToB : STD_LOGIC;
	signal SMBR : STD_LOGIC;
	signal SendRyToACC : STD_LOGIC;
	signal SLL8_ALU : STD_LOGIC;
	signal SRA8_SR : STD_LOGIC;
	signal SLL5_ALU : STD_LOGIC;
	signal SRA5_SR : STD_LOGIC;
	signal SRL8_SR : STD_LOGIC;
	signal CPRx : STD_LOGIC;
	signal CPRy : STD_LOGIC;
	signal CPRz : STD_LOGIC;
	signal BeqzPC : STD_LOGIC;
	signal SendPCtoB : STD_LOGIC;
	signal CPZF : STD_LOGIC;
	signal SendMBRtoACC : STD_LOGIC;
	
--	procedure RiToB(Reg:in STD_LOGIC_VECTOR (2 downto 0)) is
--	begin
--		case Reg is
--			when "000"=>B<=r0;
--			when "001"=>B<=r1;
--			when "010"=>B<=r2;
--			when "011"=>B<=r3;
--			when "100"=>B<=r4;
--			when "101"=>B<=r5;
--			when "110"=>B<=r6;
--			when "111"=>B<=r7;
--			when others=>NULL;
--		end case;
--	end RiToB;
--	
--	procedure RiToAcc(Reg:in STD_LOGIC_VECTOR (2 downto 0)) is
--	begin
--		case Reg is
--			when "000"=>Acc<=r0;
--			when "001"=>Acc<=r1;
--			when "010"=>Acc<=r2;
--			when "011"=>Acc<=r3;
--			when "100"=>Acc<=r4;
--			when "101"=>Acc<=r5;
--			when "110"=>Acc<=r6;
--			when "111"=>Acc<=r7;
--			when others=>NULL;
--		end case;
--	end RiToAcc;
----	
--	procedure CPRi(target:in STD_LOGIC_VECTOR (2 downto 0)) is
--	begin
--		case target is
--			when "000"=>r0<=data;
--			when "001"=>r2<=data;
--			when "010"=>r2<=data;
--			when "011"=>r3<=data;
--			when "100"=>r4<=data;
--			when "101"=>r5<=data;
--			when "110"=>r6<=data;
--			when "111"=>r7<=data;
--			when others=>NULL;
--		end case;
--	end CPRi;
	
begin

process(RST, CLK) begin
	if ( RST = '0' ) then
		-- 记得清零指令信号
		OUTPUT <= (others => '0');
		MachineState <= 0;
	elsif ( CLK'event and CLK = '1' ) then
		case MachineState is
			when 0 => 
				Fe <= '1'; Ex <= '0';
				MachineState <= 1;
				OUTPUT <= IR;
			when 1 =>
				Fe <= '0'; Ex <= '1';
				MachineState <= 0;
				-- OUTPUT <= data;
			when others => NULL;
		end case;
	end if;
end process;

process(Fe) begin
	if (Fe = '1') then
		SIR <= '1';
	end if;
		SIR <= '0';
end process;

-- 从拨码开关取指, 顺便decode
process(SIR) begin
	if (SIR = '1') then 
		IR <= INPUT;
		op <= INPUT(15 downto 11);
		-- SIR <= '0';
	end if;
end process;

-- decode
process(op, IR) begin
	case op is
		when "10011" => 
			LW <= '1'; SW <= '0'; LI <= '0'; BEQZ <= '0'; ADDIU <= '0'; ADDU <= '0'; Branch <= '0';
			rx <= IR(10 downto 8);
			ry <= IR(7 downto 5);
			rz <= "000";
		when "11011" => 
			LW <= '0'; SW <= '1'; LI <= '0'; BEQZ <= '0'; ADDIU <= '0'; ADDU <= '0'; Branch <= '0';
			rx <= IR(10 downto 8);
			ry <= IR(7 downto 5);
			rz <= "000";
		when "01101" => 
			LW <= '0'; SW <= '0'; LI <= '1'; BEQZ <= '0'; ADDIU <= '0'; ADDU <= '0'; Branch <= '0';
			rx <= IR(10 downto 8);
			ry <= "000";
			rz <= "000";
		when "00100" => 
			LW <= '0'; SW <= '0'; LI <= '0'; BEQZ <= '1'; ADDIU <= '0'; ADDU <= '0'; Branch <= '0'; 
			rx <= IR(10 downto 8);
			ry <= "000";
			rz <= "000";
		when "01001" => 
			LW <= '0'; SW <= '0'; LI <= '0'; BEQZ <= '0'; ADDIU <= '1'; ADDU <= '0'; Branch <= '0';
			rx <= IR(10 downto 8);
			ry <= "000";
			rz <= "000";
		when "11100" =>
			LW <= '0'; SW <= '0'; LI <= '0'; BEQZ <= '0'; ADDIU <= '0'; ADDU <= '1'; Branch <= '0';
			rx <= IR(10 downto 8);
			ry <= IR(7 downto 5);
			rz <= IR(4 downto 2);
		when "00010" =>
			LW <= '0'; SW <= '0'; LI <= '0'; BEQZ <= '0'; ADDIU <= '0'; ADDU <= '0'; Branch <= '1'; 
			rx <= "000";
			ry <= "000";
			rz <= "000";
		when others => NULL;
	end case;
end process;

-- 节拍发生器
process(Ex, CLK0) begin

	ClockState <= 0;

	if Ex = '1' then
		if ( CLK0'event and CLK0 = '1' ) then
			case ClockState is
				when 0 =>
					ClockState <= 1;
					T0 <= '1'; T1 <= '0'; T2 <= '0'; T3 <= '0';
				when 1 =>
					ClockState <= 2;
					T0 <= '0'; T1 <= '1'; T2 <= '0'; T3 <= '0';
				when 2 =>
					ClockState <= 3;
					T0 <= '0'; T1 <= '0'; T2 <= '1'; T3 <= '0';
				when 3 =>
					ClockState <= 0;
					T0 <= '0'; T1 <= '0'; T2 <= '0'; T3 <= '1';	
			end case;
		end if;
	end if;
end process;

-- control unit: send many signals
process(T0, T1, T2, T3,
			Fe, Ex, BEQZ, SW, LW, ADDU, ADDIU, BRANCH, LI
		) begin
	SendPCtoAcc <= (Fe and T1) or (Ex and T3 and BEQZ);
	Pass_ALU <= (Fe and T1) or (Ex and T2 and SW) or (Ex and T3 and LW);
	DM_SR <= (Fe and T1) or (Ex and T1 and LW) or (Ex and T2 and SW) or (Ex and T3 and (LW or ADDIU or ADDU or Branch));
	CPMAR <= (Fe and T1) or (Ex and T1 and (LW or SW)) or (Ex and T2 and SW);
	EMAR <= (Fe and T2) or (Ex and T2 and LW) or (Ex and T3 and SW);
	R <= (Fe and T2) or (Ex and T2 and LW);
	W <= Ex and T3 and SW;
	-- SIR
	-- 1 -> B
	Add_ALU <= (Fe and T2) or (Ex and T1 and (LW or SW)) or (Ex and T3 and (BEQZ or ADDIU or ADDU or Branch));
	CPPC <= (Fe and T2) or (Ex and T3 and (BEQZ or Branch));
	SendIRtoAcc <= Ex and ((T0 and (LW or SW)) or (T2 and (BEQZ or ADDIU or Branch)) or (T3 and LI));
	SLL11_ALU <= Ex and T0 and (LW or SW);
	SRA11_SR <= Ex and T0 and (LW or SW);
	CPACC <= (Ex and T0 and (LW or SW)) or (Ex and T2 and (BEQZ or ADDIU or Branch));
	SendRxToB <= Ex and ((T1 and (LW or SW)) or (T3 and (ADDIU or ADDU))); -- send ri 不要用边沿传输数据
	SendRyToACC <= Ex and ((T2 and SW) or (T3 and ADDU));
	CPRx <= Ex and T3 and (ADDIU or LI);
	CPRy <= Ex and T3 and LW;
	CPRz <= Ex and T3 and ADDU;
	SMBR <= Ex and T2 and LW;
	SLL8_ALU <= Ex and ((T2 and (BEQZ or ADDIU)) or (T3 and LI));
	SRA8_SR <= Ex and T2 and (BEQZ or ADDIU);
	SLL5_ALU <= Ex and T2 and Branch;
	SRA5_SR <= Ex and T2 and Branch;
	SRL8_SR <= Ex and T3 and LI;
	-- pc + zf*c -> pc
	SendPCtoB <= Ex and T3 and Branch;
	CPZF <= Ex and T2 and BEQZ;
end process;

process(
		SendPCtoAcc, Pass_ALU, DM_SR, CPMAR, EMAR, R, W,
		ADD_ALU, CPPC, SendIRtoAcc, SLL11_ALU, SRA11_SR,
		CPACC, SMBR, SLL8_ALU, SRA8_SR, SLL5_ALU, SRA5_SR, SRL8_SR,
		SendPCtoB, CPZF, SendMBRtoACC,SendRxToB, SendRyToACC, CPRx, CPRy, CPRz,
		PC, ACC, SR, DATA, B, IR, MBR, RX, RY, RZ, R0, R1, R2, R3, R4, R5 ,R6, R7
		)
begin

	if SendPCtoAcc = '1' then Acc <= pc; end if;
	if Pass_ALU = '1' then SR <= Acc; end if;
	if DM_SR = '1' then data <= SR; end if;
	if CPMAR = '1' then MAR <= data; end if;
--	if EMAR = '1' then M_EN <= '0'; end if;
--	if R = '1' then
--		M_OE <= '0';
--		M_WE <= '1';
--		M_Addr <= MAR;
--		M_Data <= (others => 'Z');
--		MBR <= M_data;
--	end if;
--	if W = '1' then
--		M_WE <= '0';
--		M_OE <= '1';
--		M_Data <= MBR;
--		M_Addr <= MAR;
--	end if;
	if ADD_ALU = '1' then SR <= ACC + B; end if;
	if CPPC = '1' then PC <= data; end if;
	if SendIRtoAcc = '1' then Acc <= IR; end if;
	if SLL11_ALU = '1' then SR <= to_stdlogicvector(to_bitvector(Acc) sll 11); end if;
	if SRA11_SR = '1' then data <= to_stdlogicvector(to_bitvector(SR) sra 11); end if;
	if CPACC = '1' then Acc <= data; end if;
	if SMBR = '1' then MBR <= data; end if;
	if SLL8_ALU = '1' then SR <= to_stdlogicvector(to_bitvector(Acc) sll 8); end if;
	if SRA8_SR = '1' then data <= to_stdlogicvector(to_bitvector(SR) sra 8); end if;
	if SLL5_ALU = '1' then SR <= to_stdlogicvector(to_bitvector(Acc) sll 5); end if;
	if SRA5_SR = '1' then data <= to_stdlogicvector(to_bitvector(SR) sra 5); end if;
	if SendPCtoB = '1' then B <= PC; end if;
	--  if CPZF = '1' then if 
	if SendMBRtoACC = '1' then Acc <= MBR; end if;
	
	if SendRxToB = '1' then
		case Rx is
			when "000" => B <= r0;
			when "001" => B <= r1;
			when "010" => B <= r2;
			when "011" => B <= r3;
			when "100" => B <= r4;
			when "101" => B <= r5;
			when "110" => B <= r6;
			when "111" => B <= r7;
			when others=> NULL;
		end case;
	end if;
	if SendRyToACC = '1' then
		case Rx is
			when "000" => Acc <= r0;
			when "001" => Acc <= r1;
			when "010" => Acc <= r2;
			when "011" => Acc <= r3;
			when "100" => Acc <= r4;
			when "101" => Acc <= r5;
			when "110" => Acc <= r6;
			when "111" => Acc <= r7;
			when others=> NULL;
		end case;
	end if;
	if CPRx = '1' then 
		case rx is
			when "000"=>r0<=data;
			when "001"=>r2<=data;
			when "010"=>r2<=data;
			when "011"=>r3<=data;
			when "100"=>r4<=data;
			when "101"=>r5<=data;
			when "110"=>r6<=data;
			when "111"=>r7<=data;
			when others=>NULL;
		end case;
	end if;
	if CPRy = '1' then 		
		case ry is
			when "000"=>r0<=data;
			when "001"=>r2<=data;
			when "010"=>r2<=data;
			when "011"=>r3<=data;
			when "100"=>r4<=data;
			when "101"=>r5<=data;
			when "110"=>r6<=data;
			when "111"=>r7<=data;
			when others=>NULL;
		end case;
	end if;
	if CPRz = '1' then 
		case rz is
			when "000"=>r0<=data;
			when "001"=>r2<=data;
			when "010"=>r2<=data;
			when "011"=>r3<=data;
			when "100"=>r4<=data;
			when "101"=>r5<=data;
			when "110"=>r6<=data;
			when "111"=>r7<=data;
			when others=>NULL;
		end case;
	end if;
	
end process;


end bhv;